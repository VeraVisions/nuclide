//======= Copyright (c) 2015-2020 Vera Visions LLC. All rights reserved. =======
//
// Purpose: 
//
// Blending terrain and masking its edges for a smooth transition into alpha.
//==============================================================================

!!ver 110
!!permu FOG
!!permu BUMP
!!permu DELUXE
!!permu UPPERLOWER
!!samps diffuse normalmap

!!samps lightmap
!!samps =LIGHTSTYLED lightmap1 lightmap2 lightmap3
!!samps =DELUXE deluxemap
!!samps =LIGHTSTYLED =DELUXE deluxemap1 deluxemap2 deluxemap3
!!samps =UPPERLOWER upper

!!permu FAKESHADOWS
!!cvardf r_glsl_pcf
!!cvardf r_fullbright
!!samps =FAKESHADOWS shadowmap

!!cvardf r_skipDiffuse
!!cvardf r_skipLightmap
!!cvardf r_skipNormal

#include "sys/defs.h"

varying vec2 tex_c;
varying vec4 vex_color;

varying vec2 lm0;
#ifdef LIGHTSTYLED
varying vec2 lm1, lm2, lm3;
#endif

#ifdef FAKESHADOWS
	varying vec4 vtexprojcoord;
#endif

#ifdef VERTEX_SHADER
	void lightmapped_init(void)
	{
		lm0 = v_lmcoord;
		#ifdef LIGHTSTYLED
		lm1 = v_lmcoord2;
		lm2 = v_lmcoord3;
		lm3 = v_lmcoord4;
		#endif
	}

	void main ( void )
	{
		lightmapped_init();
		tex_c = v_texcoord;
		vex_color = v_colour;

		gl_Position = ftetransform();
		
		#ifdef FAKESHADOWS
		vtexprojcoord = (l_cubematrix*vec4(v_position.xyz, 1.0));
		#endif
	}
#endif

#ifdef FRAGMENT_SHADER
	#include "sys/fog.h"
	#include "sys/pcf.h"

#if r_skipLightmap==0
	#ifdef LIGHTSTYLED
		#define LIGHTMAP0 texture2D(s_lightmap0, lm0).rgb
		#define LIGHTMAP1 texture2D(s_lightmap1, lm1).rgb
		#define LIGHTMAP2 texture2D(s_lightmap2, lm2).rgb
		#define LIGHTMAP3 texture2D(s_lightmap3, lm3).rgb
	#else
		#define LIGHTMAP texture2D(s_lightmap, lm0).rgb 
	#endif
#else
	#ifdef LIGHTSTYLED
		#define LIGHTMAP0 vec3(0.5,0.5,0.5)
		#define LIGHTMAP1 vec3(0.5,0.5,0.5)
		#define LIGHTMAP2 vec3(0.5,0.5,0.5)
		#define LIGHTMAP3 vec3(0.5,0.5,0.5)
	#else
		#define LIGHTMAP vec3(0.5,0.5,0.5)
	#endif
#endif

	vec3 lightmap_fragment()
	{
		vec3 lightmaps;

#ifdef LIGHTSTYLED
		lightmaps  = LIGHTMAP0 * e_lmscale[0].rgb;
		lightmaps += LIGHTMAP1 * e_lmscale[1].rgb;
		lightmaps += LIGHTMAP2 * e_lmscale[2].rgb;
		lightmaps += LIGHTMAP3 * e_lmscale[3].rgb;
#else
		lightmaps  = LIGHTMAP * e_lmscale.rgb;
#endif
		return (r_fullbright == 1) ? vec3(1.0, 1.0, 1.0) : lightmaps;
	}

#if r_skipNormal==0
	vec3 lightmap_fragment(vec3 normal_f)
	{
#ifndef DELUXE
		return lightmap_fragment();
#else
		vec3 lightmaps;

	#if defined(LIGHTSTYLED)
		lightmaps  = LIGHTMAP0 * e_lmscale[0].rgb * dot(normal_f, (texture2D(s_deluxemap0, lm0).rgb - 0.5) * 2.0);
		lightmaps += LIGHTMAP1 * e_lmscale[1].rgb * dot(normal_f, (texture2D(s_deluxemap1, lm1).rgb - 0.5) * 2.0);
		lightmaps += LIGHTMAP2 * e_lmscale[2].rgb * dot(normal_f, (texture2D(s_deluxemap2, lm2).rgb - 0.5) * 2.0);
		lightmaps += LIGHTMAP3 * e_lmscale[3].rgb * dot(normal_f, (texture2D(s_deluxemap3, lm3).rgb - 0.5) * 2.0);
	#else 
		lightmaps  = LIGHTMAP * e_lmscale.rgb * dot(normal_f, (texture2D(s_deluxemap, lm0).rgb - 0.5) * 2.0);
	#endif

		return (r_fullbright == 1) ? vec3(1.0, 1.0, 1.0) : lightmaps;
#endif
	}
#endif

	void main ( void )
	{
	#if r_skipDiffuse==0
		vec3 diffuse_f = texture2D(s_diffuse, tex_c).rgb;
	#else
		vec3 diffuse_f = vec3(1.0,1.0,1.0);
	#endif

		float bw = 1.0 - (diffuse_f.r + diffuse_f.g + diffuse_f.b) / 3.0;
		vec4 vcol = vex_color;

	#if r_skipNormal==0
		vec3 normal_f;
		normal_f = normalize(texture2D(s_normalmap, tex_c).rgb - 0.5);
	#endif

		if (vcol.a < 1.0) {
		// contrast enhancement
		#ifdef BWMASK
			bw *= ((bw * 2.0) * BWMASK);
		#endif
			if (bw > vcol.a) {
				discard;
			}
		}

	#if r_skipNormal==0
		diffuse_f.rgb *= lightmap_fragment(normal_f);
	#else
		diffuse_f.rgb *= lightmap_fragment();
	#endif

		#ifdef FAKESHADOWS
		diffuse_f *= ShadowmapFilter(s_shadowmap, vtexprojcoord);
		#endif

		#if defined(UPPERLOWER)
			diffuse_f.rgb *= (texture2D(s_upper, tex_c * 4.0).rgb + 0.5);
		#endif

		gl_FragColor = vec4(fog3(diffuse_f), 1.0);
	}
#endif
