.float deaths;

/** @defgroup serverAPI API: Server-side
    @brief Server-side Game-Logic APIs
    @ingroup multiprogs
    @ingroup server

APIs used by MapC progs, game rules and the server progs exclusively.

# AddonC {#addonC}
An addon plugin manager that sits between the game and Nuclide.
It allows for the dynamic injection of additions to gameplay or functionality.

Handled by ncAddonDelegate. Which contains usage details.

# MapC {#mapC}
Map specific code.
This allows maps to react to information generated by game events.

Handled by ncMapDelegate.

# RuleC {#ruleC}
Game rule specific progs. You can see ncRuleDelegate for more details, as it is the acting body of any active game rule.

@{
*/

/** Util library */
typedef struct
{
	/** Returns the current time.

	@param realTime specifies the time in seconds since 01/01/1970.
	@param zoneType specifies the time zone to use. 0 = UTC, 1 = Local.
	@param formatString is a C-language, strftime styled string setting the output format
	@return Euler-angles generated from the input. */
	string TimeToString(int realTime, int zoneType, string formatString);
} utilAPI_t;
var utilAPI_t util; /**< Access utilAPI_t functions using this variable. */

/** Exists library */
typedef struct
{
	/** Check whether a named entity class exists in the current map/level.

	@param className specifies entity class to look for.
	@return when `true`, exists in the current map/level. */
	bool InMap(string className);
	/** Check whether an entity is within a PVS - if it is visible from a certain location and vice-versa.

	@param lookingEntity is the entity that we test visibility against
	@param visiblePosition is the position they may be able to see
	@return when `true`, they're in each other their potentially-visible-set. */
	bool InPVS(entity lookingEntity, vector visiblePosition);
	/** Check whether a file is present in the virtual filesystem.

	@param fileName specifies the file to look for relative to the game directory. E.g. "maps/start.bsp"
	@return when `true`, exists in the virtual filesystem. */
	bool InVFS(string fileName);
} existsAPI_t;
var existsAPI_t exists; /**< Access existsAPI_t functions using this variable. */

/** Ents library */
typedef struct
{
	/** Creates a new entity of a given class name.
	It is guaranteed to return an entity, unless you
	have run out of memory.

	@param className the type of entity class to create.
	@param spawnPos the position at which it should spawn.
	@return The created entity. */
	entity Create(string className, vector spawnPos);
	/** Transitions an entity from one class to another.

	@param targetEntity is the target entity.
	@param className is the class type to change targetEntity to.
	@return The created entity. */
	float ChangeToClass(entity targetEntity, string className);
	/** Sends an input (See ncIO::Input) to an entity.

	While you're able to manipulate entities in most ways using bare MapC, you might want to change Nuclide specific attributes of them as well. This can only be done using the I/O system.

	For the variety of inputs an entity supports, please look at the respective entity-specific documentation.

	@param target is the entity which will receive the input
	@param inputName is the name of the input. E.g. "SetOrigin"
	@param dataString contains parameters for the input. E.g. "0 0 0"
	@param activator references which entity is "responsible" for triggering this input. */
	void Input(entity target, string inputName, string dataString, entity activator);
} entsAPI_t;
var entsAPI_t ents; /**< Access entsAPI_t functions using this variable. */

/** Game library */
typedef struct
{
	/** Force loads the next map/level in the rotation. If none is set, the map will restart.*/
	void LoadNextMap(void);
	/** Removed any temporary game entities from the game, and resets the state of the level to the default state. */
	void CleanUpMap(void);
	/** Returns the name of the map/level.

	@return the name of the map/level, such as `"tw_grime"` */
	string GetMap(void);
	/** Returns the name of the next map/level in the rotation.

	@return the name of the map/level, such as `"tw_dune"` */
	string GetNextMap(void);
	/** Sets the default spawn-point class to custom one. Does not affect members of teams, which have their own API. 
	@param spawnPointClass is the name of the spawn-point class, such as `"info_player_start"`. */
	void SetSpawnPoint(string spawnPointClass);
	/** Teleports an entity to their ideal spawn-point.
	@param teleportingEntity is the entity to teleport. */
	void TeleportToSpawn(entity teleportingEntity);
	/** Return a random instance of a specified entity class.
	@param entityClassName is the desired entity class name, such as "info_player_deathmatch". 
	@return a valid entity result, or `__NULL__` when not existant in the map/level. */
	entity FindRandomClassObject(string entityClassName);
} gameAPI_t;
var gameAPI_t game; /**< Access gameAPI_t functions using this variable. */

/** MOTD library */
typedef struct
{
	/** Loads the message of the day from the default location: `<gamedir>/motd.txt` */
	void LoadDefault(void);
	/** Loads a text file as an input for a message of the day.

	@return the path of the text file relative to the game directory, such as `"ctf_motd.txt"` */
	void LoadFromFile(string);
} motdAPI_t;
var motdAPI_t motd; /**< Access motdAPI_t functions using this variable. */

/** MOTD library */
typedef struct
{
	/** Returns a tokenizable string containing a list of inventory items of a specified actor (this includes players).
	@return the tokenizable string. Exaple output: `"item_book item_wallet item_multitool"` */
	string GetInventory(entity targetActor);
	/** Returns whether an item class exists in an actor's inventory.
	@return `true` or `false` if the item is present. */
	bool HasItem(entity targetActor, string itemClass);
	/** Returns the amount of reserve ammo of a given ammo type ID.
	@param targetActor is the actor to query ammo information from.
	@param ammoType ammo type ID, which you can discover with [ammo.NumForName()](@ref ammoAPI_t).
	@return integer value reflecting the reserve ammo requested. */
	int GetReserveAmmo(entity targetActor, int ammoType);
	/** Returns the amount of maximum ammo of a given ammo type ID.
	@param targetActor is the actor to query ammo information from.
	@param ammoType ammo type ID, which you can discover with [ammo.NumForName()](@ref ammoAPI_t).
	@return integer value reflecting the maximum ammo. */
	bool MaxAmmo(entity targetActor, int ammoType);
	/** Returns the current amount of actors in the game. Not counting dead ones.
	@return integer value of the total amount of actors. */
	int TotalActors(void);
	/** Returns the current amount of actors in the game, on a specific team. Not counting dead ones.
	@param teamID is the id of a team set up with the [teams API](@ref teamAPI_t)
	@return integer value of the total amount of actors in a team. */
	int TotalActorsOnTeam(int teamID);

	float AimAtPos(entity, vector);
	float MoveToPos(entity, vector);
	bool CanSee(entity, entity);
	bool CanShoot(entity, vector, vector);
	bool ClearEnemy();
	entity FindCoverNode(entity);
} actorAPI_t;
var actorAPI_t actor; /**< Access actorAPI_t functions using this variable. */

/** Combat library */
typedef struct
{
	/** Applies damage to a given entity.
	Requires the use of damageDef/entityDef since we're run out of parameters in QuakeC.

	@param targetEnt is the entity receiving the damage.
	@param inflictingEnt is the entity causing the damage (e.g. a projectile, rocket)
	@param attackingEnt is the entity owning up to the damage.
	@param damageDef is the damageDef containing all the info, including damage points
	@param damageOrigin is the location where the damage comes from.
	@param damageDir is the direction the damage is coming from.
	@param hitLocation is the final hit location, where the damage is applied. */
	void Damage(entity targetEnt, entity inflictingEnt, entity attackingEnt, string damageDef, vector damageOrigin, vector damageDir, vector hitLocation);
	/** Does damage to all entities within a specified radius with a linear falloff.
	If a negative damageMax value is supplied, then no collision checks will be performed.
	So radiusDamage calls will not be obstructed by level or entity geometry.

	@param damageCenter is the location of the center, at which the wave originates.
	@param damageRange is the radius (in game units) of the wave.
	@param damageMax is the maximum damage that can be done by this wave.
	@param damageMin is the minimum amount of damage done, at the very edge.
	@param attackingEnt is the entity owning up to the damage.
	@param damageDef is decl containing damage info. */
	void RadiusDamage(vector damageCenter, float damageRange, int damageMin, int damageMax, entity attackingEnt, string damageDef);
	/** Lets everyone in the game know that something, or something, has passed.

	@param targetName is the entity that has passed away.
	@param attackerName is responsible. Can be empty.
	@param weaponDef is the weapon used. Can be empty.
	@param meansOfDeath is the additional means. Could mean something extra. */
	void Obituary(string targetName, string attackerName, string weaponDef, string meansOfDeath);
} combatAPI_t;
var combatAPI_t combat; /**< Access combatAPI_t functions using this variable. */

/** @} */ // end of multiprogs

__variant
linkToServerProgs(string funcName)
{
	static void empty(void)
	{
		print("Called unimplemented server-side API call.\n");
		breakpoint();
	}

	void *func = externvalue(0, funcName);

	if (func) {
		return ((__variant)func);
	} else {
		return (empty);
	}
}

void
_server_main(void)
{
	game.LoadNextMap = linkToServerProgs("SVPF_game_LoadNextMap");
	game.CleanUpMap = linkToServerProgs("SVPF_game_CleanUpMap");
	game.GetMap = linkToServerProgs("SVPF_game_GetMap");
	game.GetNextMap = linkToServerProgs("SVPF_game_GetNextMap");
	game.SetSpawnPoint = linkToServerProgs("SVPF_game_SetSpawnPoint");
	game.TeleportToSpawn = linkToServerProgs("SVPF_game_TeleportToSpawn");
	game.FindRandomClassObject = linkToServerProgs("Spawn_SelectRandom");

	combat.Damage = linkToServerProgs("SVPF_combat_Damage");
	combat.RadiusDamage = linkToServerProgs("SVPF_combat_RadiusDamage");
	combat.Obituary = linkToServerProgs("SVPF_combat_Obituary");

	ents.Create = linkToServerProgs("SVPF_ents_Create");
	ents.ChangeToClass = linkToServerProgs("SVPF_ents_ChangeToClass");
	ents.Input = linkToServerProgs("SVPF_ents_Input");

	actor.GetInventory = linkToServerProgs("SVPF_actor_GetInventory");
	actor.GetReserveAmmo = linkToServerProgs("SVPF_actor_GetReserveAmmo");
	actor.MaxAmmo = linkToServerProgs("SVPF_actor_MaxAmmo");
	actor.TotalActors = linkToServerProgs("SVPF_actor_TotalActors");
	actor.TotalActorsOnTeam = linkToServerProgs("SVPF_actor_TotalActorsOnTeam");
	actor.MoveToPos = linkToServerProgs("SVPF_actor_MoveToPos");
	actor.HasItem = linkToServerProgs("SVPF_actor_HasItem");

	exists.InMap = linkToServerProgs("SVPF_exists_InMap");
	exists.InVFS = linkToServerProgs("SVPF_exists_InVFS");
	exists.InPVS = linkToServerProgs("SVPF_exists_InPVS");

	motd.LoadDefault = linkToServerProgs("MOTD_LoadDefault");
	motd.LoadFromFile = linkToServerProgs("MOTD_LoadFromFile");

	util.TimeToString = linkToServerProgs("SVPF_util_TimeToString");
}
